# Start Up 
@Generated by `GPT`


# 📄 **Spec: `auto-gitmoji` – Gitmoji Commit Enhancer Tool**

## 🚀 Overview

`auto-gitmoji` or `amoji` is a command-line tool written in **Rust** that simplifies Git commit workflows by automatically prepending a relevant **gitmoji** to a commit message. It provides smart matching based on commit message content, enhancing readability and team collaboration.

Example usage:

```bash
amoji "add a new feature"
```

Output (terminal):

```bash
:sparkles: add a new feature
```

Git command executed:

```bash
git commit -m ":sparkles: add a new feature"
```

## 🧠 Core Requirements

### CLI Behavior

* Accepts a **single string argument**: the commit message.
* Infers and prepends the appropriate gitmoji.
* Executes `git commit -m "<emoji> message"` under the hood.
* Prints the final full message with the rendered emoji in the console.

---

## 🧱 Project Structure

```bash
amoji/
├── src/
│   ├── main.rs
│   ├── cli.rs
│   ├── matcher/
│   │   ├── mod.rs
│   │   ├── simple.rs        # Keyword matching
│   │   ├── semantic.rs      # Embedding/model-based
│   │   └── llm.rs           # API/LLM matching
│   ├── commit.rs
│   ├── emoji.rs
│   └── utils.rs
├── Cargo.toml
└── README.md
```

---

## 🔁 Flow Breakdown

1. **User Input**: CLI accepts message: `amoji "fix a bug in login"`
2. **Gitmoji Matching**: Uses selected matcher to get emoji code: `:bug:`
3. **Commit**: Final message becomes `:bug: fix a bug in login`
4. **Git Commit**: Run: `git commit -m ":bug: fix a bug in login"`
5. **Console Output**:

   ```
   🐛 fix a bug in login
   ```

---

## 🧩 Modules

### `cli.rs`

Handles argument parsing and matcher selection.

```rust
pub struct Args {
    pub message: String,
    pub matcher: MatcherType, // Optional: defaults to `simple`
}

pub enum MatcherType {
    Simple,
    Semantic,
    LLM,
}
```

Uses `clap` or `structopt` for CLI parsing.

---

### `matcher/mod.rs`

Trait definition and dynamic dispatch for matcher strategies.

```rust
pub trait GitmojiMatcher {
    fn match_emoji(&self, message: &str) -> String;
}

pub enum MatcherType {
    Simple,
    Semantic,
    LLM,
}

pub fn get_matcher(t: MatcherType) -> Box<dyn GitmojiMatcher> {
    match t {
        MatcherType::Simple => Box::new(simple::SimpleMatcher::new()),
        MatcherType::Semantic => Box::new(semantic::SemanticMatcher::new()),
        MatcherType::LLM => Box::new(llm::LLMMatcher::new()),
    }
}
```

---

### `matcher/simple.rs`

Basic keyword-to-emoji map matching.

```rust
use super::GitmojiMatcher;

pub struct SimpleMatcher;

impl SimpleMatcher {
    pub fn new() -> Self {
        Self
    }
}

impl GitmojiMatcher for SimpleMatcher {
    fn match_emoji(&self, message: &str) -> String {
        // e.g. if "fix" => ":bug:"
        // fallback: ":memo:"
    }
}
```

---

### `matcher/semantic.rs` *(Optional)*

More advanced method using local ML model or embedding similarity.

* Could integrate with HuggingFace or use `onnx` if local.
* Requires additional dependencies and weights.

---

### `matcher/llm.rs` *(Optional)*

Uses an external LLM API (e.g., OpenAI) to suggest an emoji.

* Requires API Key.
* Fallbacks if no network/API failure.

```rust
impl GitmojiMatcher for LLMMatcher {
    fn match_emoji(&self, message: &str) -> String {
        // Uses an LLM API to get the best matching gitmoji
    }
}
```

---

### `emoji.rs`

* Contains the full emoji lookup table (code → emoji + description).
* Can be a static JSON or Rust HashMap.

```rust
pub fn code_to_unicode(code: &str) -> &str {
    match code {
        ":sparkles:" => "✨",
        ":bug:" => "🐛",
        _ => "📝",
    }
}
```

---

### `commit.rs`

Responsible for executing the actual `git commit`.

```rust
pub fn git_commit(final_message: &str) -> Result<(), Error> {
    let status = Command::new("git")
        .arg("commit")
        .arg("-m")
        .arg(final_message)
        .status()?;

    if !status.success() {
        return Err(anyhow!("Git commit failed"));
    }
    Ok(())
}
```

---

## 📦 Dependencies

Suggested crates:

```toml
[dependencies]
clap = "4.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
reqwest = { version = "0.11", features = ["json"] }
anyhow = "1.0"
```

---

## 🧪 Sample Gitmoji Keyword Map

```json
{
  "fix": ":bug:",
  "add": ":sparkles:",
  "remove": ":fire:",
  "docs": ":memo:",
  "refactor": ":recycle:",
  "test": ":test_tube:"
}
```

Stored as embedded static JSON or hardcoded in `emoji.rs`.

---

## 🧱 Extensibility

Each matcher conforms to a common interface (`GitmojiMatcher`), making it simple to:

* Add new matching strategies.
* Toggle between strategies via CLI flag (`--matcher semantic`).

---

## 🧪 Testing Strategy

* Unit test each matcher independently.
* Mock git commit execution in tests.
* Include integration tests: from message input to printed output.

---

## 💬 Future Ideas

* Interactive prompt if multiple emojis are relevant.
* Option to auto-render emoji (vs. emoji code).
* Custom emoji config file per project.
* Fallback strategies (e.g., LLM → simple).

---

Let me know if you’d like a starter `main.rs` scaffold or initial matcher implementation next.
